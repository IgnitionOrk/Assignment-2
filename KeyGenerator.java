/**
 * Student name: Student Number:
 * 	1) Ryan Cunneen: 3179234
 * 	2) Jonathan Low: 3279624
 *	This class takes a 56-bit key and generates 16 subkeys according to the DES standard. The order is reversed for decryption
 * */

public class KeyGenerator {
	private int rNumber; //used to traverse the array of keys Ki
	private int iCount; //the current number of subkeys (incremented each time a key is added)
	private String[] subkeys; //contains the list of subkeys generated by generateSubkeys()
	private boolean reverseKeys;
	
	//the following permutations are standard DES permutations
	private int[] shifts = new int[]{1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1}; 
	private final int[] PC1 = new int[]{57,49,41,33,25,17,9,1,58,50,42,34,26,18,10,2,59,51,43,35,27,19,11,3,60,52,44,36,63,55,47,39,31,23,15,7,62,54,46,38,30,22,14,6,61,53,45,37,29,21,13,5,28,20,12,4};
	private final int[] PC2 = new int[]{14,17,11,24,1,5,3,28,15,6,21,10,23,19,12,4,26,8,16,7,27,20,13,2,41,52,31,37,47,55,30,40,51,45,33,48,44,49,39,56,34,53,46,42,50,36,29,32};
	
	private final String BIT = "1";
	private final String COMPLEMENT = "0";
	
	/**
	 * @param key 
	 * @param decrypting
	 */
	public KeyGenerator(boolean decrypting, String key){
		this.iCount = 0;
		this.subkeys = new String[shifts.length]; //one subkey per shift (=16)
		this.reverseKeys = decrypting; //decryption will use a reverse ordering of the keys
		this.generateSubkeys(key);
	}

	/**
	 * Initializes the subkey array 
	 * @param mode: A 1-bit used to determine if we are encrypting or decrypting. 1 = decrypting, otherwise we are encrypting. 
	 * @param key
	 */
	private void generateSubkeys(String key){
		//depending on if we're decrypting or encrypting, start at the beginning or end of int shifts[]
		if(reverseKeys){
			// Begin at the very end of the generated subkey array.
			this.rNumber = shifts.length;
		}
		else{
			this.rNumber = -1;
		}

		iCount = 0;
		key = padded(key); //take our 56 bit key and pad every eighth bit
		key = Transposition.permute(key, PC1); //then use PC1 to return a 56 bit key (different to the input 56 bit key)
		subkeys(key); //generate 16 subkeys
	}

	/**
	 * @param key
	 * @return
	 */
	private String padded(String key){
		int eLength = 7;
		String padded = "";
		String sevenBits = "";

		//loop through the key and add a bit in every eighth but which is the previous 7 bits XORed
		for(int lowerBound = 0, upperBound = eLength; lowerBound < key.length() / eLength; lowerBound++, upperBound += eLength){
			sevenBits = key.substring(lowerBound * eLength, upperBound);
			// initial seven bits, but with an additional bit, return from the xor function. 
			padded += sevenBits+eighthBit(sevenBits);
		}
		return padded;
	}

	/**
	 * @param sevenBits a string containing only 1's and 0's of length 7
	 * @return
	 */
	private String eighthBit(String sevenBits){
		//If there is an even number of 'BITs' return the complement of BIT
		//this method effectively takes the XOR of the seven bits
		if(count(sevenBits) % 2 == 0){
			return COMPLEMENT;	
		}
		else{
			return BIT;
		}
	}

	/**
	 * Determines the number of occurrences of BIT within the argument 'sevenBits'.
	 * @param sevenBits
	 * @return
	 */
	private int count(String sevenBits){
		int count = 0;
		
		for(int i = 0; i < sevenBits.length() - 1; i++){ //loop through the string character by character
			if(sevenBits.substring(i, i + 1).equals(BIT)){ //compare each bit to our target char
				count++; //if they match then increase the count
			}
		}

		return count;
	}

	/**
	 * 
	 * @param key
	 */
	private void subkeys(String key) {
		String c = "";
		String d = "";

		for(int i = 0; i < subkeys.length; i++){ //loop for each subkey we need to generated
			//take the left shift of the left and right sides of the key, leftShift depends on the value of shifts[i]
			c = leftShift(i, leftSide(key));
			d = leftShift(i, rightSide(key));
			key = c + d;
			add(Transposition.permute(key, PC2)); //permute our key then add it to the array of keys
		}
	}

	/**
	 * @param round
	 * @param side
	 * @return
	 */
	private String leftShift(int round, String side){
		int shift = shifts[round];
		String text = "";

		for(int i = 0, index = 0; i < side.length(); i++){ //loop character by character through String side
			index = (i + shift) % side.length(); //add the character located at side[i+SHIFT] where SHIFT is either 1 or 2
			text += side.substring(index, index + 1);
		}
		
		return text;
	}

	/**
	 * @param subkey
	 */
	private void add(String subkey){ //add the key and increment key count
		subkeys[iCount] = subkey;
		iCount++;
	}

	/**
	 * @param iRound
	 * @return
	 */	
	/*
	public String subkey(){
		if(reverseKeys){
			rNumber--;
		}
		else{
			rNumber++;
		}
		return subkeys[rNumber];
	}
	*/

	/**
	 * @param key
	 * @return
	 */
	private String leftSide(String key){
		return key.substring(0, (key.length() / 2)); //return characters 0 to length/2
	}

	/**
	 * @param key
	 * @return
	 */
	private String rightSide(String key){
		return key.substring((key.length() / 2), key.length());
	}
}
